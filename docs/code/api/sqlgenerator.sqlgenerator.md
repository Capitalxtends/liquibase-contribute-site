---
title: sqlgenerator.SqlGenerator
---

# liquibase.sqlgenerator.SqlGenerator Interface

## Overview

`liquibase.statement.SqlStatement` implementations define specific operations that can be run against a database, such as 
`liquibase.statement.core.CreateTableStatement` or `liquibase.statement.core.DropColumnStatement`. 
However, they only define the **_what_**, not the **_how_**. 

It is the job of the `liquibase.sqlgenerator.SqlGenerator` implementations to know how to actually apply those operations to a given database.

For more information on change types, see the [change types guide](../../../code/api/change-change.md).

!!! tip

    The default SqlGenerators for a given SqlStatement are named by replacing "Statement" from the class name with "Generator".
    For example, CreateTableStatement -> CreateTableGenerator.

    For SqlGenerators that handle specific environments, append a description of what makes it different to the end.
    For example, CreateTableStatement -> CreateTableGeneratorOracle

!!! tip

    If you are looking to define a new operation, create a new `SqlStatement` class and then the `SqlGenerator` for it.

```mermaid
sequenceDiagram
    Calling Code->>SqlStatement: Creates and configures
    Calling Code->>Executor: execute(sqlStatement)
    Executor->>SqlGeneratorFactory: generateSql(sqlStatement)
    SqlGeneratorFactory->>SqlGenerator: generateSql
    SqlGenerator-->>SqlGeneratorFactory: returns SQL
    SqlGeneratorFactory-->>Executor: returns SQL
    Executor->>Database: Executes SQL
```

!!! example

    When parsing a changelog file, Liquibase creates a `CreateTableChange` object with the table name and column definitions specified in the changelog file.
    When the Change is "executed", it will first create a `CreateTableStatement` object containing the same information and pass that to the `Executor`. 
    Liquibase will then go through all the available `SqlGenerators` that say they support `CreateTableStatement` for the given database and use the one with the
    highest priority to come up with the actual SQL to run in order to create the table.


## SqlGenerator Selection

Each `SqlGenerator` has a `supports()` method which the `SqlGeneratorFactory` uses to determine which implementations can apply the SqlStatement to the given database.

Of all the supported `SqlGenerator` implementations, Liquibase will use the one with the highest [priority](../../extension-references/priority.md).
This allows extensions to either define a default logic for a SqlStatement OR override other SqlGenerators with a better implementation.

## API Highlights

### Empty Constructor

Liquibase requires implementations to have an empty constructor.

### supports()

This method returns whether your SqlGenerator can be used for the given SqlStatement and Database.

If you define your SqlGenerator class using generics, Liquibase will know the SqlStatement type you can support and not have to rely on supports() unless the SqlStatement class is correct.
Therefore, you only have to check that the Database object is correct.

!!! warning

    Do not return `true` for SqlStatements your logic cannot handle. 

    The default implementation from `AbstractSqlGenerator` returns `true`, which is too broad for database-specific SqlGenerator implementations

### getPriority()

Is used as other [priority](../../extension-references/priority.md) values to control which SqlGenerator implementation to use out of all the ones that support the SqlStatement.

If unsure, use `PRIORITY_DEFAULT` for default/standard logic and `PRIORITY_DATABASE` for logic unique to a database.

!!! tip

    When extending an existing SqlGenerator class, you **_must_** override getPriority() so it will be picked over the base implementation you are extending. 
    If you do not override this function they will both return the same priority and one will be chosen at random.

    To ensure a higher value is returned, `return super.getPriority() + 5`.

### generateSql()

Returns the SQL to run as [liquibase.sql.Sql](https://javadocs.liquibase.com/liquibase-core/liquibase/sql/Sql.html){:target="_blank"} objects.

The normal class to use for those `Sql` objects is `liquibase.sql.UnparsedSql`.

This function returns an array of Sql statements because a single logical statement may require multiple SQL statements in some database.
For example, `AddPrimaryKeyGenerator` may return a SQL call to add the primary key and another to reorganize the table.

!!! tip

    **When extending an existing SqlGenerator**

    Depending on how different your SQL is from the base class you can either call `super.generateSql()` and modify the objects in the array before returning it, 
    OR create a new `Sql[]` array from scratch. 

    It tends to be best to modify the SQL generated by the parent class because that keeps you from having to duplicate all the
    argument handling logic that already exists in the parent. One approach is to call `super.generateSql()` and then create new `UnparsedSql` objects 
    using the `originalSql.toSql()` value passed through string replacements. 

    Also remember to always check your parent class's signature for methods it defines. It may have methods like `nullComesBeforeType()` which it uses to determine
    the final SQL and you simply have to override that method to get the correct SQL.

!!! tip

    When creating SQL, make sure you wrap object names in `database.escape...()` calls to correctly handle reserved words 
    and `database.escapeStringForDatabase()` around any string literals to handle special characters like `'` inside them.  

### validate()

Called to validate whether the SqlStatement is correctly configured. For example, if your logic requires the tableName to be set, add that to the `ValidationErrors` that is returned.

This method is always called, and so you do not need to re-validate configuration in other methods.

If you have no additional validation to perform vs. the base logic there is no need to override this method.

The `warn(SqlStatement, Database, SqlGeneratorChange)` method is similar to validate but returns non-fatal warnings to the user.

!!! tip

    When extending a base SqlGenerator, you can call `super.validate(statement, database, sqlGeneratorChain)` as a starting point, 
    then perform extra checks (or remove not-actually-invalid errors) before returning the [ValidationErrors](https://javadocs.liquibase.com/liquibase-core/liquibase/exception/ValidationErrors.html){:target="_blank"}.

### generateStatementsIsVolatile()

Ideally, your logic should be able to generate the correct SQL purely from the information stored in the SqlStatement object.

However, if you cannot do that and instead need to check the database state or other external environments, you need to return `true` from this method to mark it as "volatile".
That lets Liquibase know that for commands such `updateSql`, it cannot rely on what your `generateSql` method returns because the internal database state is not actually correct.


### Registration

Change classes are registered by adding it to `META-INF/services/liquibase.sqlgenerator.SqlGenerator`

## API Details

The complete javadocs for `liquibase.sqlgenerator.SqlGenerator` [is available at https://javadocs.liquibase.com](https://javadocs.liquibase.com/liquibase-core/liquibase/sqlgenerator/SqlGenerator.html){:target="_blank"}
