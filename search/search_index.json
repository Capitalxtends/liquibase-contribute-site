{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to contribute.liquibase.com</p>"},{"location":"development/","title":"Index","text":""},{"location":"development/#contributing","title":"Contributing","text":"<p>Thank you for your interest in contributing to Liquibase! :tada:</p> <ul> <li>Contributing Etiquette</li> <li>Creating an Issue<ul> <li>Creating a Good Code Reproduction</li> </ul> </li> <li>Creating a Pull Request<ul> <li>Requirements</li> <li>Setup</li> <li>Core<ul> <li>Modifying Components</li> <li>Preview Changes</li> <li>Lint Changes</li> <li>Modifying Documentation</li> <li>Modifying Tests<ul> <li>Screenshot Tests</li> </ul> </li> <li>Building Changes</li> </ul> </li> <li>Angular, React, and Vue<ul> <li>Modifying Files</li> <li>Preview Changes</li> <li>Lint Changes</li> <li>Modifying Tests</li> <li>Building Changes</li> </ul> </li> <li>Submit Pull Request</li> </ul> </li> <li>Commit Message Guidelines<ul> <li>Commit Message Format</li> <li>Revert</li> <li>Type</li> <li>Scope</li> <li>Subject</li> <li>Body</li> <li>Footer</li> <li>Examples</li> </ul> </li> <li>License</li> </ul>"},{"location":"development/#contributing-etiquette","title":"Contributing Etiquette","text":"<p>Please see our Contributor Code of Conduct for information on our rules of conduct.</p>"},{"location":"development/#creating-an-issue","title":"Creating an Issue","text":"<ul> <li>If you have a question about using the liquibase, please ask on the Liquibase Forum or in the Liquibase Discord.</li> <li>It is required that you clearly describe the steps necessary to reproduce the issue you are running into. Although we would love to help our users as much as possible, diagnosing issues without clear reproduction steps is extremely time-consuming and simply not sustainable.</li> <li>The issue list of this repository is exclusively for bug reports and feature requests. Non-conforming issues will be closed immediately.</li> <li> <p>If you think you have found a bug, or have a new feature idea, please start by making sure it hasn't already been reported. You can search through existing issues to see if there is a similar one reported. Include closed issues as it may have been closed with a solution.</p> </li> <li> <p>Next, create a new issue that thoroughly explains the problem. Please fill out the populated issue form before submitting the issue.</p> </li> </ul>"},{"location":"development/#creating-a-pull-request","title":"Creating a Pull Request","text":"<p>Before creating a pull request, please read our requirements that explains the minimal details to have your PR considered and merged into the codebase.</p>"},{"location":"development/#requirements","title":"Requirements","text":"<ol> <li>PRs should reference a existing issue(s) that describes the issue or feature being submitted. A PR should be about the \"how\" not the \"what\", but for code cleanup/refactoring/quick-bugfixes the PR can be self-contained and not reference an issue. </li> <li>PRs must have the description template filled out, describing the changes you are making and why plus choices and considerations you made.</li> <li>PRs must include tests covering the changed behavior or a description of why tests cannot be written.</li> </ol>  <p>Note: We appreciate you taking the time to contribute! Before submitting a pull request, please take the time to comment on the issue you are wanting to resolve. This helps us prevent duplicate effort or advise if the team is already addressing the issue.</p>  <ul> <li>Looking for an issue to fix? Look through our issues with the good first issue label!</li> </ul>"},{"location":"development/#setup","title":"Setup","text":""},{"location":"development/#minimal-setup","title":"Minimal Setup","text":"<ol> <li>Install Java. Any version or distribution of Java will work, but the current LTS version is usually best</li> <li>Install Maven. Unzip the archive to a directory on your system. This provides the <code>mvn</code> CLI. </li> <li>Fork this repository.</li> <li>Clone your fork.</li> <li>Create a new branch from master for your change. Name it something descriptive (but short).</li> <li>Run <code>mvn package</code> which compiles Liquibase, runs the tests, and creates the jar/tar.gz packages</li> </ol>"},{"location":"development/#ide-setup","title":"IDE Setup","text":"<p>The \"Minimal Setup\" section builds and tests your local branch, but generally you will want to use and IDE like VS Code,  IntelliJ IDEA, or your own favorite environment.  </p> <p>Both IDEs allow you to import that base pom.xml file as your \"project\" which keeps the libraries and build logic the IDE uses in sync with what is defined in canonical pom.xml that Maven uses.</p>"},{"location":"development/#running-builds","title":"Running Builds","text":""},{"location":"development/#maven-builds","title":"Maven Builds","text":"<p>Running <code>mvn clean install</code> will build your local code and package the CLI archive as <code>liquibase-dist/target/liquibase-0-SNAPSHOT.tar.gz</code>. Untarring this file will get you a complete \"liquibase home\" directory which you can use like any other release distribution for running your local code.</p> <p>This will also install the <code>liquibase-maven-plugin</code> to your local Maven cache as version <code>0-SNAPSHOT</code> which allows you to run the local build of the maven plugin code. To use it in a test project, update the plugin reference to:</p> <pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.liquibase&lt;/groupId&gt;\n    &lt;artifactId&gt;liquibase-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;0-SNAPSHOT&lt;/version&gt;\n    &lt;!-- ... additional settings ... --&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"development/#running-the-cli-in-your-ide","title":"Running the CLI In your IDE","text":"<p>The maven-built package listed above works, but it's the most efficient way of working. The build process takes a while, and it's difficult to enable debug support. Instead, when using an IDE with more \"native\" support for running classes, you can run the CLI class more directly.</p> <p>Exactly how you configure your IDE to run the CLI depend on the version you are using, but the general process is to create a new \"Run Configuration\" with the following settings: - Class to run: <code>liquibase.integration.commandline.LiquibaseLauncher</code> - Module Classpath: <code>liquibase-cli</code> - Environment Variable: <code>LIQUIBASE_HOME=&lt;PATH_TO_A_LIQUIBASE_HOME&gt;</code> - Environment Variable: <code>LIQUIBASE_LAUNCHER_PARENT_CLASSLOADER=thread</code> - Working Directory: <code>&lt;PATH_TO_A_LIQUIBASE_HOME&gt;</code> - Program Arguments: Whatever you are looking to test</p> <p>Both the LIQUIBASE_HOME and working directory should be set to a directory where you installed a previous version of Liquibase as a starting point.  When Liquibase runs, it will use the jars in <code>lib</code> and <code>internal/lib</code> so you can add any needed drivers or extensions to those directories like you would in a production build.</p> <p>Your run configuration should allow you to successfully run Liquibase in either regular mode or debug mode.  It's always good to ensure you can successfully run the CLI from the current master branch before making changes locally. </p>"},{"location":"development/#working-with-the-code","title":"Working with the Code","text":""},{"location":"development/#high-level-layout","title":"High Level Layout","text":"<p>The Liquibase repository is divided into a series of submodules, including: - <code>liquibase-core</code> which contains most of the code - <code>liquibase-cli</code> and <code>liquibase-emaven-plugin</code> which include the CLI and Maven Plugin integrations respectively - <code>liquibase-dist</code> which contains the final \"distributions\" - <code>liquibase-integration-tests</code> which contains tests that run against databases - And more</p> <p>Within each submodule, the code is structured following the Maven standard layout, with: - <code>src</code> containing all the source code - <code>src/main</code> containing the \"production\" code - <code>src/main/java</code> containing the \"production\" Java code - <code>src/main/resources</code> containing static files for the \"production\" artifacts - <code>src/test</code> containing the \"test\" code - <code>src/test/java</code> and <code>src/test/groovy</code> containing the \"test\" java and groovy code - <code>src/test/resources</code>containing static files for use in tests</p>"},{"location":"development/#modifying-components","title":"Modifying Components","text":"<ol> <li>Locate the component(s) to modify inside <code>/core/src/components/</code>.</li> <li>Take a look at the Stencil Documentation and other components to understand the implementation of these components.</li> <li>Make your changes to the component. If the change is overly complex or out of the ordinary, add comments so we can understand the changes.</li> <li>Preview your changes locally.</li> <li>Modify the documentation if needed.</li> <li>Run lint on the directory and make sure there are no errors.</li> <li>Build the project.</li> <li>After the build is finished, commit the changes. Please follow the commit message format for every commit.</li> <li>Submit a Pull Request of your changes.</li> </ol>"},{"location":"development/#preview-changes","title":"Preview Changes","text":"<ol> <li>Run <code>npm start</code> from within the <code>core</code> directory.</li> <li>A browser should open at <code>http://localhost:3333/</code>.</li> <li>From here, navigate to one of the component's tests to preview your changes.</li> <li>If a test showing your change doesn't exist, add a new test or update an existing one.</li> <li>To test in RTL mode, once you are in the desired component's test, add <code>?rtl=true</code> at the end of the url; for example: <code>http://localhost:3333/src/components/alert/test/basic?rtl=true</code>.</li> </ol>"},{"location":"development/#lint-changes","title":"Lint Changes","text":"<ol> <li>Run <code>npm run lint</code> to lint the TypeScript and Sass.</li> <li>If there are lint errors, run <code>npm run lint.fix</code> to automatically fix any errors. Repeat step 1 to ensure the errors have been fixed, and manually fix them if not.</li> <li>To lint and fix only TypeScript errors, run <code>npm run lint.ts</code> and <code>npm run lint.ts.fix</code>, respectively.</li> <li>To lint and fix only Sass errors, run <code>npm run lint.sass</code> and <code>npm run lint.sass.fix</code>, respectively.</li> </ol>"},{"location":"development/#modifying-documentation","title":"Modifying Documentation","text":"<ul> <li>Changes to manually written documentation should be made in the <code>ionic-docs</code> repo: https://github.com/ionic-team/ionic-docs/tree/main/docs<ul> <li>In your <code>ionic-docs</code> PR, please add a link back to the related <code>ionic-framework</code> PR.</li> </ul> </li> <li>Changes to auto generated documentation should be made in the <code>ionic-framework</code> repo. These can be done in the same PR as your fix or feature.<ul> <li>Run <code>npm run build</code> and commit all updates to ensure your changes make it into the generated documentation.</li> <li><code>Usage</code>: update the component's usage examples in the component's <code>usage/</code> directory.</li> <li><code>Properties</code>, <code>Events</code>, or <code>Methods</code>: update the component's TypeScript file (<code>*.tsx</code>).</li> <li><code>CSS Custom Properties</code>: update the component's main Sass file (<code>*.scss</code>).</li> </ul> </li> </ul>"},{"location":"development/#modifying-tests","title":"Modifying Tests","text":"<ol> <li>Locate the test to modify inside the <code>test/</code> folder in the component's directory.</li> <li>If a test exists, modify the test by adding an example to reproduce the problem fixed or feature added.</li> <li>If a new test is needed, the easiest way is to copy the <code>basic/</code> directory from the component's <code>test/</code> directory, rename it, and edit the content in both the <code>index.html</code> and <code>e2e.ts</code> file (see Screenshot Tests for more information on this file).</li> <li>The <code>preview/</code> directory is used in the documentation as a demo. Only update this test if there is a bug in the test or if the API has a change that hasn't been updated in the test.</li> </ol>"},{"location":"development/#screenshot-tests","title":"Screenshot Tests","text":"<ol> <li>If the test exists in screenshot, there will be a file named <code>e2e.ts</code> in the directory of the test.</li> <li>A screenshot test can be added by including this file and adding one or more <code>test()</code> calls that include a call to <code>page.compareScreenshot()</code>. See Stencil end-to-end testing and existing tests in <code>core/</code> for examples.</li> <li>Important: each <code>test()</code> should have only one screenshot (<code>page.compareScreenshot()</code>) call or it should check the expect at the end of each test. If there is a mismatch it will fail the test which will prevent the rest of the test from running, i.e. if the first screenshot fails the remaining screenshot calls would not be called unless they are in a separate test or all of the expects are called at the end.</li> <li>To run screenshot locally, use the following command: <code>npm run test.screenshot</code>.<ul> <li>To run screenshot for a specific test, pass the path to the test or a string to search for.</li> <li>For example, running all <code>alert</code> tests: <code>npm run test.screenshot alert</code>.</li> <li>Or, running the basic <code>alert</code> tests: <code>npm run test.screenshot src/components/alert/test/basic/e2e.ts</code>.</li> </ul> </li> </ol>"},{"location":"development/#building-changes","title":"Building Changes","text":"<ol> <li>Once all changes have been made and the documentation has been updated, run <code>npm run build</code> inside of the <code>core</code> directory. This will add your changes to any auto-generated files, if necessary.</li> <li>Review the changes and, if everything looks correct, commit the changes.</li> <li>Make sure the build has finished before committing. If you made changes to the documentation, properties, methods, or anything else that requires an update to a generate file, this needs to be committed.</li> <li>After the changes have been pushed, publish the branch and create a pull request.</li> </ol>"},{"location":"development/#submit-pull-request","title":"Submit Pull Request","text":"<ol> <li>Create a new pull request with the <code>main</code> branch as the <code>base</code>. You may need to click on <code>compare across forks</code> to find your changes.</li> <li>See the Creating a pull request from a fork GitHub help article for more information.</li> <li>Please fill out the provided Pull Request template to the best of your ability and include any issues that are related.</li> </ol>"},{"location":"development/#review-process-for-feature-prs","title":"Review Process for Feature PRs","text":"<p>The team has an internal design process for new Ionic features, which must be completed before the PR can be reviewed or merged. As a result of the design process, community feature PRs are subject to large changes. In some cases, the team may instead create a separate PR using pieces of the community PR. Either way, you will always receive co-author commit credit when the feature is merged.</p> <p>To expedite the process, please ensure that all feature PRs have an associated issue created, with a clear use case for why the feature should be added to Ionic.</p>"},{"location":"development/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<p>We have very precise rules over how our git commit messages should be formatted. This leads to readable messages that are easy to follow when looking through the project history. We also use the git commit messages to generate our changelog. Our format closely resembles Angular's commit message guidelines.</p>"},{"location":"development/#commit-message-format","title":"Commit Message Format","text":"<p>We follow the Conventional Commits specification. A commit message consists of a header, body and footer.  The header has a type, scope and subject:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n&lt;BLANK LINE&gt;\n&lt;body&gt;\n&lt;BLANK LINE&gt;\n&lt;footer&gt;\n</code></pre> <p>The header is mandatory and the scope of the header is optional.</p>"},{"location":"development/#revert","title":"Revert","text":"<p>If the commit reverts a previous commit, it should begin with <code>revert:</code>, followed by the header of the reverted commit. In the body it should say: <code>This reverts commit &lt;hash&gt;.</code>, where the hash is the SHA of the commit being reverted.</p>"},{"location":"development/#type","title":"Type","text":"<p>If the prefix is <code>feat</code>, <code>fix</code> or <code>perf</code>, it will appear in the changelog. However if there is any BREAKING CHANGE, the commit will always appear in the changelog.</p> <p>Must be one of the following:</p> <ul> <li>feat: A new feature</li> <li>fix: A bug fix</li> <li>docs: Documentation only changes</li> <li>style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)</li> <li>refactor: A code change that neither fixes a bug nor adds a feature</li> <li>perf: A code change that improves performance</li> <li>test: Adding missing tests</li> <li>chore: Changes to the build process or auxiliary tools and libraries such as documentation generation</li> </ul>"},{"location":"development/#scope","title":"Scope","text":"<p>The scope can be anything specifying place of the commit change. Usually it will refer to a component but it can also refer to a utility. For example <code>action-sheet</code>, <code>button</code>, <code>css</code>, <code>menu</code>, <code>nav</code>, etc. If you make multiple commits for the same component, please keep the naming of this component consistent. For example, if you make a change to navigation and the first commit is <code>fix(nav)</code>, you should continue to use <code>nav</code> for any more commits related to navigation. As a general rule, if you're modifying a component use the name of the folder.</p>"},{"location":"development/#subject","title":"Subject","text":"<p>The subject contains succinct description of the change:</p> <ul> <li>use the imperative, present tense: \"change\" not \"changed\" nor \"changes\"</li> <li>do not capitalize first letter</li> <li>do not place a period <code>.</code> at the end</li> <li>entire length of the commit message must not go over 50 characters</li> <li>describe what the commit does, not what issue it relates to or fixes</li> <li>be brief, yet descriptive - we should have a good understanding of what the commit does by reading the subject</li> </ul>"},{"location":"development/#body","title":"Body","text":"<p>Just as in the subject, use the imperative, present tense: \"change\" not \"changed\" nor \"changes\". The body should include the motivation for the change and contrast this with previous behavior.</p>"},{"location":"development/#footer","title":"Footer","text":"<p>The footer should contain any information about Breaking Changes and is also the place to reference GitHub issues that this commit Closes.</p> <p>Breaking Changes should start with the word <code>BREAKING CHANGE:</code> with a space or two newlines. The rest of the commit message is then used for this.</p>"},{"location":"development/#examples","title":"Examples","text":"<p>Does not appear in the generated changelog:</p> <pre><code>docs(changelog): update steps to update\n</code></pre> <p>Appears under \"Features\" header, toast subheader:</p> <pre><code>feat(toast): add 'buttons' property\n</code></pre> <p>Appears under \"Bug Fixes\" header, skeleton-text subheader, with a link to issue #28:</p> <pre><code>fix(skeleton-text): use proper color when animated\n\ncloses #28\n</code></pre> <p>Appears under \"Performance Improvements\" header, and under \"Breaking Changes\" with the breaking change explanation:</p> <pre><code>perf(css): remove all css utility attributes\n\nBREAKING CHANGE: The CSS utility attributes have been removed. Use CSS classes instead.\n</code></pre> <p>Appears under \"Breaking Changes\" with the breaking change explanation:</p> <pre><code>refactor(animations): update to new animation system\n\nBREAKING CHANGE:\n\nRemoves the old animation system to use the new Ionic animations.\n</code></pre> <p>The following commit and commit <code>667ecc1</code> do not appear in the changelog if they are under the same release. If not, the revert commit appears under the \"Reverts\" header.</p> <pre><code>revert: feat(skeleton-text): add animated property\n\nThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\n</code></pre>"},{"location":"development/#license","title":"License","text":"<p>By contributing your code to the ionic-team/ionic GitHub Repository, you agree to license your contribution under the MIT license.</p>"},{"location":"extensions/","title":"Extensions Overview","text":"<p>Liquibase is built with extensibility in mind. From generic changelog file handling to database-specific logic,  almost every part of Liquibase can be customized and enhanced through the extension system.  In fact, all standard functionality that ships as part of Liquibase is built using the same extension system.</p>"},{"location":"extensions/#what-can-extensions-do","title":"What can extensions do?","text":"<p>Here are some examples of what you can achieve through extensions:</p> <ul> <li>Modify behavior for specific databases</li> <li>Create custom change types and preconditions</li> <li>Create new commands or enhance existing commands with new logic</li> </ul> <p>If you'd like to have a more comprehensive overview of the Extension API,  refer to the Extension Guides for code samples and guides that illustrate various Extension API usage.</p>"},{"location":"extensions/#how-to-build-extensions","title":"How to build extensions?","text":"<p>Building a good extension can take a lot of time and effort.  Here is what each section of the API docs can help you with:</p> <ul> <li>Your First Extension teaches fundamental concepts for building extensions with the Hello World sample.</li> <li>Extension Anatomy describes how extension code works together.</li> <li>Extension Guides includes guides and code samples that explain specific usages of the API.</li> <li>Best Practices showcases best practices for providing a great user experience with your extension.</li> </ul>"},{"location":"extensions/#looking-for-help","title":"Looking for help?","text":"<p>If you have questions for extension development, try asking on:</p> <ul> <li>Liquibase Forum Great place to ask questions, discuss, and help other members of the community.</li> <li>Liquibase Discord For real time questions and discussion</li> </ul>"},{"location":"extensions/best-practices/","title":"Extension Best Practices","text":""},{"location":"extensions/best-practices/#play-nicely-with-others","title":"Play Nicely With Others","text":"<p>Remember that users will install a variety of extensions, not just yours. That means you should always be enabling your functionality only when it should be used.</p> <p>For example, in <code>getPriority()</code> methods, make sure you are returning <code>NOT_APPLICABLE</code> when your code is not applicable. Or in <code>supports()</code> calls, make sure you return <code>false</code> if that is not a database your code is trying to support.</p>"},{"location":"extensions/best-practices/#be-open-to-extension","title":"Be Open to Extension","text":"<p>Remember that just like you are looking to improve Liquibase, others will want to improve your extension. Be open to extension with both your code and your configuration.</p> <p>For example, don't return <code>Integer.MAX_VALUE</code> in <code>getPriority()</code>. Also, consider extracting portions of your logic to protected methods that someone else can subclass and override in their own extensions.</p>"},{"location":"extensions/extension-anatomy/","title":"Extension Anatomy","text":"<p>In Your First Extension, you were able to get a basic extension running. How does it work under the hood?</p> <p>Liquibase is implemented in Java and relies on standard Java patterns such as \"code to interfaces, dynamically load implementations\". </p> <p>While the specific methods can vary by extension, the general pattern is:</p> <ol> <li>On startup, Liquibase finds all available implementations of extension interfaces</li> <li>As Liquibase runs, when it needs to use a particular interface it finds and uses the implementation with the highest priority based on the surrounding context</li> </ol> <p>This pattern means that creating extensions consists of:</p> <ol> <li>Creating new classes (implementations) for interfaces with the new or changed logic you want.</li> <li>Ensure your new classes return a high enough <code>priority</code> value in the contexts they should apply</li> <li>Register classes, so they are found at startup time</li> </ol> <p>Let's take a closer look at the HelloWorldChange sample's source code and see how these concepts apply to it.</p>"},{"location":"extensions/extension-anatomy/#extension-file-structure","title":"Extension File Structure","text":"<pre><code>./src/main/java/com/example/change/HelloWorldChange.java\n./src/main/resources/META-INF/services/liquibase.change.Change\n./pom.xml\n</code></pre>"},{"location":"extensions/extension-anatomy/#helloworldchangejava","title":"HelloWorldChange.java","text":"<p>This class is your new implementation of the liquibase.change.Change interface which defines your new logic in the <code>generateStatements()</code></p> <p>The priority of this implementation is set via the <code>priority</code> attribute on the <code>@DatabaseChange</code> annotation.  It uses the <code>PRIORITY_DEFAULT</code> constant which is \"1\"</p>"},{"location":"extensions/extension-anatomy/#meta-infservices","title":"META-INF/services","text":"<p>Because HelloWorldChange is providing a new liquibase.change.Change implementation, we create (or add to) a file named <code>liquibase.change.Change</code> in <code>META-INF/services</code> and list the class name in there.</p> <p>This file is used by Liquibase at startup time to know your new implementation exists.</p>"},{"location":"extensions/extension-anatomy/#pomxml","title":"pom.xml","text":"<p>The pom.xml file contains the build logic Maven uses for compiling and packaging your code into a jar file. </p> <p>The jar file contains your new implementation class and adding it to Liquibase's <code>lib</code> directory allows the CLI to find it and use it. </p>"},{"location":"extensions/your-first-extension/","title":"Your First Extension","text":"<p>This page will teach you the fundamental concepts for building extensions.</p> <p>Liquibase extensions are built with Java, so you will likely want a  Java-friendly IDE and a build tool like Maven or Gradle</p> <p>For a starting Maven-based project, you can create a personal repository based on the example extension template.</p> <p>The example extension defines:</p> <ul> <li>A new <code>clearPasswords</code> change type</li> <li>A new <code>prefix</code> attribute for <code>createTable</code> </li> <li>A new <code>hasPasswordColumn</code> precondition</li> </ul> <p>From the base directory, run <code>mvn package</code> to build the extension as <code>target/my-example-0.0.1.jar</code>.</p> <p>Copy <code>my-example-0.0.1.jar</code> to your <code>LIQUIBASE_HOME/lib</code> directory and run the changelog found in the <code>project</code> directory. That will create a table called <code>secure_user_table</code>, check that the <code>password</code> column exists, and clear out any values in that column.</p>"},{"location":"extensions/your-first-extension/#developing-the-extension","title":"Developing the extension","text":"<p>Let's make a \"hello world\" change type:</p>"},{"location":"extensions/your-first-extension/#create-helloworldchangejava","title":"Create HelloWorldChange.java","text":"<p>Create <code>src/main/java/com/example/change/HelloWorldChange.java</code> as</p> <pre><code>package com.example.change;\n\nimport liquibase.change.AbstractChange;\nimport liquibase.change.ChangeMetaData;\nimport liquibase.change.DatabaseChange;\nimport liquibase.database.Database;\nimport liquibase.statement.SqlStatement;\nimport liquibase.statement.core.RawSqlStatement;\n\n@DatabaseChange(name = \"helloWorld\", description = \"Says hi\", priority = ChangeMetaData.PRIORITY_DEFAULT)\npublic class HelloWorldChange extends AbstractChange {\n    @Override\n    public SqlStatement[] generateStatements(Database database) {\n        return new SqlStatement[] {\n                new RawSqlStatement(\"create table hello(world int)\")\n        };\n    }\n\n    @Override\n    public String getConfirmationMessage() {\n        return \"Said hello\";\n    }\n}\n</code></pre> <p>and add <code>com.example.change.HelloWorldChange</code> to <code>src/main/resources/META-INF/services/liquibase.change.Change</code> so it looks like:</p> <pre><code>com.example.change.ClearPasswordsChange\ncom.example.change.PrefixedCreateTableChange\ncom.example.change.HelloWorldChange\n</code></pre> <p>then rebuild with <code>mvn package</code> and re-copy <code>target/my-extension-0.0.1.jar</code> to <code>LIQUIBASE_HOME/lib</code>.</p> <p>Finally, add a new changeset to your changelog file like:</p> <pre><code>    &lt;changeSet id=\"4\" author=\"example\"&gt;\n        &lt;ext:helloWorld/&gt;\n    &lt;/changeSet&gt;\n</code></pre> <p>and when you run <code>liquibase update</code> you will now have a table named <code>hello</code> with a column named <code>world</code>. </p> <p>Here are some ideas for things you can try:</p> <ul> <li>Change the name of the table created by <code>helloWorld</code></li> <li>Add a \"dataType\" parameter to <code>helloWorld</code></li> </ul>"},{"location":"extensions/your-first-extension/#next-steps","title":"Next Steps","text":"<p>In the next topic, Extension Anatomy, we look closer at the source code of the helloWorld extension and explain key concepts.</p>"},{"location":"extensions/guides/","title":"Extension Guides","text":"<p>Once you have learned the basics of Liquibase Extensions in the HelloWorldChange sample, it's time to build some real-world extensions.</p> <p>In each guide or sample, you can expect to find:</p> <ul> <li>Thoroughly commented source code</li> <li>An example showing the usage of the sample extension</li> <li>Listing of APIs being used</li> <li>Explanation of API concepts</li> </ul>"},{"location":"extensions/guides/#guides-samples","title":"Guides &amp; Samples","text":"<p>Here are the available guides, including the APIs they use</p>    Guide Used Extension Points     Additional Database Support liquibase.database, liquibase.sqlgenerator, liquibase.snapshot"},{"location":"extensions/guides/additional-database/","title":"Additional Support for Additional Databases","text":"<p>Liquibase is designed to be cross-database and therefore separates the database-specific logic from the overall database-agnostic code. Therefore, the overall process of adding support for a new database is finding and fixing the specific places where the default database interaction logic doesn't work with your database.</p> <p>This work is broken up into two milestones:</p> <ol> <li>Compatible/Foundational Support which configures Liquibase to understand your database and get basic update/rollback logic working</li> <li>Advanced Support which ensures change and snapshot based functionality works correctly</li> </ol> <p>In each milestone, you have an end-goal of working functionality and are working with a specific subset of interfaces to implement. </p>"},{"location":"extensions/guides/additional-database/#prerequisites","title":"Prerequisites","text":"<p>Implementing support for additional databases requires an understanding of Java.  You will be creating classes, overridding methods, and working with inheritance hierarchies.</p> <p>You will also need to understand how to work with the new database. As you hit places where Liquibase incorrectly assumes particular SQL will work against your database, you will need to know what the correct SQL is.</p> <p>Finally, this section assumes you are adding support for a SQL-based database.  NoSQL and non-relational databases use this exact same process, but there will be more changes to make and you will need to re-implement more complex interfaces. Therefore, to keep this information more stream-lined it is only focusing on what needs to be done for relational database. </p>"},{"location":"extensions/guides/additional-database/#milestone-0-project-setup","title":"Milestone 0: Project Setup","text":"<p>If you have not already created a repository to hold your code, see Your First Extension in the Getting Started guide. </p>"},{"location":"extensions/guides/additional-database/#milestone-1-compatible-support","title":"Milestone 1: Compatible Support","text":"<p>The end-goal of this milestone is to have Liquibase understand how your database works and be able to run any functionality that depends on generated SQL from change tags or snapshot support. Basically \"you can run update and rollback using Formatted SQL or  the sql change type in xml/yaml/json.</p> <p>The overall steps in this milestone are:</p> <ol> <li>Create a new <code>liquibase.database.Database</code> implementation</li> <li>Test that Liquibase works with sql-based changelog files</li> <li>(If needed) Iteratively failures from step 2 until there are no more</li> </ol>"},{"location":"extensions/guides/additional-database/#step-1","title":"Step 1","text":"<p>The first step in adding support for your database is defining a new liquibase.database.Database implementation. Visit that topic for detailed information on creating that class.</p> <p>The Database implementation acts as a dialect definition and facade to your database.  The standard liquibase.changelog.ChangeLogHistoryService,  liquibase.lockservice.LockService, and liquibase.executor.Executor implementations rely on SQL and JDBC standard statements plus dialect info from your <code>Database</code> class, so will generally not need any updates.</p>"},{"location":"extensions/guides/additional-database/#step-2","title":"Step 2","text":"<p>With your Database class defined, Liquibase should be able to run user-defined SQL statements against the database. Give it a try!</p> <p>Create a changelog file like:</p> <pre><code>-- liquibase formatted sql\n\n--changeset example:1\ncreate table person (id int not null primary key, name varchar(255))\n--rollback drop table person\n\n--changeset example:2\ncreate table company (id int not null primary key, name varchar(255))\n--rollback drop table company\n</code></pre> <p>and run <code>liquibase update</code> against your database using that changelog file.  If there are any failures with creating the databasechangelog table, managing the lock, marking the change sets ran, etc. GOTO step 3.</p> <p>Once update works, any Liquibase functionality that doesn't rely on modeled changes or snapshot should work. For example, all of this should work:</p> <ul> <li><code>liquibase rollback-count 2</code></li> <li><code>liquibase history</code></li> <li><code>liquibase status</code></li> <li><code>liquibase tag</code></li> <li>Using xml/yaml/json changelog files with only <code>&lt;sql&gt;</code> and <code>&lt;sqlFile&gt;</code> tags</li> </ul>"},{"location":"extensions/guides/additional-database/#step-3","title":"Step 3","text":"<p>For this milestone, database interactions primarily consists of:</p> <ul> <li>Creates and populates <code>databasechangeloglock</code> table using very basic/standard SQL</li> <li>Creates and populates <code>databasechangelog</code> table using very basic/standard SQL</li> <li>Executes user-specified SQL</li> </ul> <p>If you run into any problems with those, the most likely fix is overriding additional <code>liquibase.database.Database</code> methods to more correctly describe how your database works. </p> <p>For example, if the <code>databasechangeloglock</code> table isn't being created correctly because your database quotes object names in a special way, override the <code>escapeObjectName</code> function. Exactly what you need to override will depend on the actual problems you hit.</p> <p>In rare cases, you may need to override one or more of the following SQLGenerators: - <code>liquibase.sqlgenerator.core.ClearDatabaseChangeLogTableGenerator</code> - <code>liquibase.sqlgenerator.core.CreateDatabaseChangeLogLockTableGenerator</code> - <code>liquibase.sqlgenerator.core.CreateDatabaseChangeLogTableGenerator</code> - <code>liquibase.sqlgenerator.core.InitializeDatabaseChangeLogLockTableGenerator</code> - <code>liquibase.sqlgenerator.core.MarkChangeSetRanGenerator</code></p>"},{"location":"extensions/guides/additional-database/#milestone-2-foundational-support","title":"Milestone 2: Foundational Support","text":"<p>If you'd like your database support to included in the main Liquibase documentation and a more official part of Liquibase, contact the Liquibase team and we can work with you to bring it more officially into the fold.</p>"},{"location":"extensions/guides/additional-database/#milestone-3-advanced-support","title":"Milestone 3: Advanced Support","text":"<p>At the end of \"milestone 1\", Liquibase works against your database in a large variety of use cases, but it does not supporting everything Liquibase can do. </p> <p>By default, the change and snapshot logic uses standard SQL and JDBC calls so many will work out of the box, but not enough to advertise support for them until you have ensured they work.</p> <p>The overall steps in this phase are: 1. Test that all the change types work correctly and all object types can be snapshotted 2. (If needed) Iteratively failures from step 1 until there are no more</p>"},{"location":"extensions/guides/additional-database/#step-1_1","title":"Step 1","text":"<p>Ensuring snapshot and changes work requires going through each specific change type and through each specific object type, then ensuring they execute correctly for all the different argument permutations that are valid for your database.</p> <p>To automate this process, Liquibase provides a Test Harness to find everywhere the default logic isn't compatible with your database. Configure your project using the steps in the Test Harness repository and run the tests.</p>"},{"location":"extensions/guides/additional-database/#step-2_1","title":"Step 2","text":"<p>Fixing the failing tests will entail creating custom liquibase.sqlgenerator.SqlGenerator and liquibase.snapshot.SnapshotGenerator extension classes. </p> <p>The general pattern for both is to create a new class which returns a higher priority if and only if Liquibase is using the <code>Database</code> class you defined in milestone 1.</p> <p>You will likely have a number of failures across the two types of functionality:</p> <ul> <li>Failing Change calls, which require you to define new SqlGenerator implementations </li> <li>Failing Snapshot calls, which require you to define a new SnapshotGenerator implementations</li> </ul> <p>Once all the Test Harness tests are passing, you will be able to use change types in XML/YAML/JSON changelogs as well as any snapshot based functionality. For example, all of this should now work:</p> <ul> <li><code>liquibase update</code> with <code>&lt;createTable...</code> in the changelog</li> <li><code>liquibase update</code> with <code>&lt;tableExists...</code> preconditions in the changelog</li> <li><code>liquibase snapshot</code></li> <li><code>liquibase diff</code></li> <li><code>liquibase diff-changelog</code></li> <li><code>liquibase generate-changelog</code></li> </ul>"},{"location":"extensions/guides/additional-database/#next-steps","title":"Next Steps","text":"<p>Congratulations! You can certainly stop here and use all the standard Liquibase functionality against your database. </p> <p>However, if there is new and unique functionality your database supports, you can always expand beyond Liquibase's standard logic to  work with it.</p> <p>Perhaps your database supports different object types? Add new <code>DatabaseObject</code> classes to your extension and snapshot in order to see them in diff operations.</p> <p>Does your database has statements or operations which you would like to wrap in custom Change functions? Add add new <code>Change</code> classes to your extension and the <code>SqlGenerator</code> for it.</p> <p>Any other new functionality can be bundled into your extension, but also think about the scope of the functionality you are adding.  If it is truly unique to this database you can certainly add it to this extension, but if it is something that can be used beyond your database it is likely best packaged as an independent exception.  </p>"},{"location":"extensions/guides/additional-database/database/","title":"Defining a New liquibase.database.Database Implementation","text":""},{"location":"extensions/guides/additional-database/database/#overview","title":"Overview","text":"<p>When adding support for a new database, the first class to create is a new liquibase.database.Database implementation. The Database class implementations act as \"dialect\" definitions and as the facade for interacting with the database.</p> <p>The Database interface methods for: - Reading metadata about the database (<code>getDatabaseMajorVersion()</code>, <code>getDefaultPort()</code>, <code>getDefaultSchema()</code>, etc.) - Checking capabilities of the database (<code>isCaseSensitive()</code>, <code>supportsInitiallyDeferrableColumns</code>, <code>supportsSchemas()</code>, etc) - Performing common logic (<code>escapeObjectName()</code>, <code>commit()</code>, <code>rollback()</code>, etc.)</p> <p>If your database generally attempts to be compatible with another database, your new Database implementation can extend an existing class. For example, if your database is PostgreSQL-compatible you can extend <code>liquibase.database.core.PostgresDatabase</code></p> <p>If your database is unique, you will likely want to extend from liquibase.database.AbstractJdbcDatabase which provides default method logic to follow SQL standards.</p>"},{"location":"extensions/guides/additional-database/database/#implementing","title":"Implementing","text":"<p>Depending on your base class you will have more or less abstract methods which must be implemented.</p>"},{"location":"extensions/guides/additional-database/database/#empty-constructor","title":"Empty Constructor","text":"<p>Like all Liquibase extensions, your database must have an empty constructor.</p>"},{"location":"extensions/guides/additional-database/database/#getpriority","title":"getPriority()","text":"<p>Generally you should return <code>liquibase.servicelocator.PrioritizedService.PRIORITY_DEFAULT</code>, but higher values can be used to replace the Database implementation that would otherwise be chosen by Liquibase (see isCorrectDatabaseImplementation) below.</p>"},{"location":"extensions/guides/additional-database/database/#getshortname","title":"getShortName()","text":"<p>The \"short name\" for the database is the unique, all-lowercase alphanumeric identifier for the database. For example <code>oracle</code> or <code>mysql</code>. This is the key used in the <code>dbms</code> tag among other places.</p>"},{"location":"extensions/guides/additional-database/database/#iscorrectdatabaseimplementationdatabaseconnection","title":"isCorrectDatabaseImplementation(DatabaseConnection)","text":"<p>This is the function used by Liquibase to determine if it is the correct Database class to use for a given connection.</p> <p>You can check whatever information best identifies the database from the connection. For example, you can check <code>getDatabaseProductName()</code> on the DatabaseConnection. Some \"compatible\" databases may identify themselves as a different database with <code>getDatabaseProductName()</code>, such as MariaDB returning \"MySQL\" from that call and you may need to also check the DatabaseConnection's <code>getDatabaseProductVersion()</code> or even <code>getURL()</code>.</p> <p>When Liquibase connects to a database, it will use the instance of <code>Database</code> which returns true from <code>isCorrectDatabaseImplementation()</code> AND has the highest number returned from <code>getPriority()</code>.</p>"},{"location":"extensions/guides/additional-database/database/#getdefaultdriverstring","title":"getDefaultDriver(String)","text":"<p>Return the class name of the default driver for the given URL string. Specifying your driver's class here allows users to not have to use the <code>driver</code> setting whenever they connect to your database.</p>"},{"location":"extensions/guides/additional-database/database/#dialect-settings","title":"Dialect settings","text":"<p>There are a few dialect settings that do not have a default implementation and therefore must be defined: - getDefaultPort() -- default port used to connect to the database - supportsInitiallyDeferrableColumns() -- does your database support initially deferrable constraints - supportsTablespaces() -- does your database support tablespaces</p> <p>For other functions where your database differs than assumptions your base class makes, override the corresponding methods.</p>"},{"location":"extensions/guides/additional-database/database/#register-your-class","title":"Register your Class","text":"<p>Like all extensions, your database must be registered by adding your class name to <code>META-INF/services/liquibase.database.Database</code></p>"},{"location":"extensions/guides/additional-database/database/#example-code","title":"Example Code","text":"<pre><code>package com.example.database;\n\nimport liquibase.database.AbstractJdbcDatabase;\nimport liquibase.database.DatabaseConnection;\nimport liquibase.exception.DatabaseException;\n\npublic class ExampleDatabase extends AbstractJdbcDatabase {\n\n    @Override\n    public int getPriority() {\n        return PRIORITY_DEFAULT;\n    }\n\n    @Override\n    public boolean isCorrectDatabaseImplementation(DatabaseConnection databaseConnection) throws DatabaseException {\n        return databaseConnection.getDatabaseProductName().equals(\"ExampleDB\");\n    }\n\n    @Override\n    public String getShortName() {\n        return \"example\";\n    }\n\n    @Override\n    protected String getDefaultDatabaseProductName() {\n        return \"Example Database\";\n    }\n\n    @Override\n    public String getDefaultDriver(String s) {\n        return \"com.example.db.Driver\";\n    }\n\n    @Override\n    public Integer getDefaultPort() {\n        return 55555;\n    }\n\n    @Override\n    public boolean supportsInitiallyDeferrableColumns() {\n        return false;\n    }\n\n    @Override\n    public boolean supportsTablespaces() {\n        return true;\n    }\n}\n</code></pre> <p>If your database is compatible with an existing database, your class would look more like this:</p> <pre><code>package com.example.database;\n\nimport liquibase.database.DatabaseConnection;\nimport liquibase.database.core.PostgresDatabase;\nimport liquibase.exception.DatabaseException;\n\npublic class ExampleDatabase extends PostgresDatabase {\n\n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n\n    @Override\n    public boolean isCorrectDatabaseImplementation(DatabaseConnection databaseConnection) throws DatabaseException {\n        return databaseConnection.getDatabaseProductName().equals(\"ExampleDB\");\n    }\n\n    @Override\n    public String getShortName() {\n        return \"example\";\n    }\n\n    @Override\n    protected String getDefaultDatabaseProductName() {\n        return \"Example Database\";\n    }\n}\n</code></pre>"},{"location":"extensions/guides/additional-database/snapshot-generator/","title":"Snapshot generator","text":""},{"location":"extensions/guides/additional-database/snapshot-generator/#defining-a-new-liquibasesnapshotsnapshotgenerator-implementation","title":"Defining a New liquibase.snapshot.SnapshotGenerator Implementation","text":""},{"location":"extensions/guides/additional-database/snapshot-generator/#overview","title":"Overview","text":"<p>Liquibase defines a database-independent metadata model in liquibase.snapshot.DatabaseSnapshot That model contains standardized liquibase.structure.DatabaseObject objects such as liquibase.structure.core.Table.</p> <p>The snapshot logic used in not just <code>liquibase snapshot</code> but also <code>liquibase diff</code> and <code>liquibase diff-changelog</code> relies on liquibase.snapshot.SnapshotGenerator implementations to read the database's metadata and create the corresponding <code>DatabaseObject</code> objects</p> <pre><code>sequenceDiagram\n    participant DatabaseSnapshot\n    participant SnapshotFactory\n    participant SnapshotGenerator\n    participant Database\n    DatabaseSnapshot-&gt;&gt;SnapshotFactory: Snapshot the DatabaseObjects\n    SnapshotFactory-&gt;&gt;SnapshotGenerator: Snapshot a particular type\n    SnapshotGenerator-&gt;&gt;Database: Executes Query\n    SnapshotGenerator--&gt;&gt;DatabaseSnapshot: Returns DatabaseObject\n</code></pre> <p>For example, to snapshot a Column SnapshotFactory will go through all the available <code>SnapshotGenerators</code> that say they support <code>Column</code> for the given database and use the one with the highest priority.</p> <p>Defining database-specific functionality tends to be writing <code>if (database instanceof ExampleDatabase)</code> blocks around the non-standard calls. Using \"instanceof\" means the block will apply to any subclasses of the given database. For example, if your database is PostgreSQL compatible and therefore your Database class extensions <code>PostgresDatabase</code> then all the <code>if (database instanceof PostgresDatabase)</code> checks will be used for your database as well.</p>"},{"location":"extensions/guides/additional-database/snapshot-generator/#implementing","title":"Implementing","text":"<p>When adding support for a new Database, there will be existing <code>SnapshotGenerator</code> implementations for all <code>DatabaseObject</code> types. It is usually easiest to subclass the existing SnapshotGenerator to leverage the standard logic, but it's not necessary.</p> <p>The naming pattern tends to be \"ObjectType\" + \"SnapshotGenerator\". For example, Column -&gt; ColumnSnapshotGenerator. Database-specific classes append the database name to the end, like <code>ColumnSnapshotGeneratorOracle</code>.</p>"},{"location":"extensions/guides/additional-database/snapshot-generator/#empty-constructor","title":"Empty Constructor","text":"<p>Like all Liquibase extensions, your SnapshotGenerator must have an empty constructor.</p>"},{"location":"extensions/guides/additional-database/snapshot-generator/#getprioritydatabasetype-database-and-replacesclass","title":"getPriority(DatabaseType, Database) and replaces(Class)","text":"<p>The <code>getPriority</code> works a bit different than other extensions in that it's not used to choose the single \"best\" implementation to use, but rather to choose the order to run SnapshotGenerators in. </p> <p>Like other getPriority methods, if your implementation does not apply for the given type/database combination, return <code>liquibase.snapshot.PRIORITY_NONE</code>.</p> <p>However, Liquibase will use ALL instances that return a priority &gt; 0 to snapshot an object.  Therefore, if your extension is replacing a base SnapshotGenerator you override the <code>replaces()</code> function rather than returning a higher value from <code>getPriority()</code>. The <code>replaces()</code> function lets you say \"use this class in the snapshot logic instead of another one\".</p> <p>A good example implementation for a class that replaces the default ColumnSnapshotGenerator is:</p> <pre><code>    @Override\n    public int getPriority(Class&lt;? extends DatabaseObject&gt; objectType, Database database) {\n        if (database instanceof ExampleDatabase) {\n            return super.getPriority(objectType, database);\n        } else {\n            return PRIORITY_NONE;\n        }\n    }\n\n    @Override\n    public Class&lt;? extends SnapshotGenerator&gt;[] replaces() {\n        return new Class[] {\n                ColumnSnapshotGenerator.class\n        };\n    }\n</code></pre> <p>which relies on the superclass's \"should I be part of the snapshot process for the given type\" logic but only for ExampleDatabase while also taking the place of ColumnSnapshotGenerator when it's used.</p>"},{"location":"extensions/guides/additional-database/snapshot-generator/#snapshotdatabaseobject-example-databasesnapshot-snapshot-snapshotgeneratorchain-chain","title":"snapshot(DatabaseObject example, DatabaseSnapshot snapshot, SnapshotGeneratorChain chain)","text":"<p>This is the function which is called by the snapshot system to either lookup the information about the given <code>example</code> object, OR add additional information to it. Multiple SnapshotGenerator instances will work together to build up the final snapshot of the object.</p> <p>The overall flow is: 1. The calling code defines the \"example\" object it wants. </p> <p>For example, if they want to snapshot a Table with the name \"address\" they construct a <code>liquibase.structure.core.Table</code> object and set the name to be \"address\".  To look up the table in a different schema, they set the schema attribute on Table to the desired schema. The \"example\" object will contain the fields set that should be used to identify the actual object to snapshot. </p> <ol> <li>The snapshot system will collect up all the SnapshotGenerators that say they should participate in the snapshot and call the <code>snapshot</code> method in <code>getPriority()</code> order.</li> </ol> <p>For example, when snapshotting an example Table, the <code>TableSnapshotGenerator.snapshot()</code> call will run first which captures the table name, schema, etc. Then the ColumnSnapshotGenerator.snapshot() will run which snapshots all the columns associated with the table and adds those columns to the Table object.</p> <ol> <li>After all the SnapshotGenerators have added their information to the Table object, it's returned to the calling code.</li> </ol> <p>There is a liquibase.snapshot.jvm.JdbcSnapshotGenerator convenience base class that is used for all the standard <code>DatabaseObject</code> SnapshotGenerators which separates the \"create the base object\" logic from the \"add to an object\" logic plus has caching built into it. </p> <p>The standard SnapshotGenerators tend to have overridable functions for commonly variable portions of the snapshot logic, so you generally shouldn't override snapshot itself but more targeted methods instead.</p>"},{"location":"extensions/guides/additional-database/snapshot-generator/#register-your-class","title":"Register your Class","text":"<p>Like all extensions, your SnapshotGenerator must be registered by adding your class name to <code>META-INF/services/liquibase.snapshot.SnapshotGenerator</code></p>"},{"location":"extensions/guides/additional-database/snapshot-generator/#example-code","title":"Example Code","text":"<pre><code>package com.example.snapshot;\n\nimport com.example.database.ExampleDatabase;\nimport liquibase.database.Database;\nimport liquibase.snapshot.CachedRow;\nimport liquibase.snapshot.SnapshotGenerator;\nimport liquibase.snapshot.jvm.ColumnSnapshotGenerator;\nimport liquibase.structure.DatabaseObject;\nimport liquibase.structure.core.Column;\n\npublic class SnapshotColumnGeneratorExample extends ColumnSnapshotGenerator {\n\n    @Override\n    public int getPriority(Class&lt;? extends DatabaseObject&gt; objectType, Database database) {\n        if (database instanceof ExampleDatabase) {\n            return super.getPriority(objectType, database);\n        } else {\n            return PRIORITY_NONE;\n        }\n    }\n\n    @Override\n    public Class&lt;? extends SnapshotGenerator&gt;[] replaces() {\n        return new Class[] {\n                ColumnSnapshotGenerator.class\n        };\n    }\n\n    @Override\n    protected Object readDefaultValue(CachedRow columnMetadataResultSet, Column columnInfo, Database database) {\n        if (columnInfo.getType().getTypeName().equalsIgnoreCase(\"json\")) {\n            return columnMetadataResultSet.get(\"default_value_json\");\n        } else {\n            return super.readDefaultValue(columnMetadataResultSet, columnInfo, database);\n        }\n    }\n}\n</code></pre>"},{"location":"extensions/guides/additional-database/sql-generator/","title":"Sql generator","text":""},{"location":"extensions/guides/additional-database/sql-generator/#defining-a-new-liquibasesqlgeneratorsqlgenerator-implementation","title":"Defining a New liquibase.sqlgenerator.SqlGenerator Implementation","text":""},{"location":"extensions/guides/additional-database/sql-generator/#overview","title":"Overview","text":"<p>Liquibase defines database-independent requests for an action in liquibase.change.Change and liquibase.statement.SqlStatement classes. Change classes are what can be called from changelog files, and SqlStatement classes describe the lower-level calls that translate more directly to SQL statement.</p> <p>Both <code>Change</code> and <code>SqlStatement</code> simply describe what wants to be done without specifying how to carry that out. It is the job of the <code>SqlGenerator</code> to create the correct SQL for a given <code>Statement</code> definition.</p> <pre><code>sequenceDiagram\n    participant Change\n    participant SqlStatement\n    participant Executor\n    participant SqlGenerator\n    Change-&gt;&gt;SqlStatement: Creates\n    Change-&gt;&gt;Executor: Passes Statement to run\n    Executor-&gt;&gt;SqlGenerator: Finds best implementation\n    SqlGenerator--&gt;&gt;Executor: Returns correct SQL for Statement\n</code></pre> <p>For example, when parsing a changelog file, Liquibase creates a <code>CreateTableChange</code> object with the table name and column definitions specified in the changelog file. When the Change is \"executed\", it will first create a <code>CreateTableStatement</code> object containing the same information and pass that to the <code>Executor</code>.  Liquibase will then go through all the available <code>SqlGenerators</code> that say they support <code>CreateTableStatement</code> for the given database and use the one with the highest priority to come up with the actual SQL to run in order to create the table.</p> <p>There will be existing <code>SqlGenerator</code> classes for all <code>SqlStatement</code>, and they will try to be database-generic, but sometimes the SQL is not valid for your database.</p> <p>For example, the default <code>AddColumnGenerator</code> may return <code>\"alter table \"+dialect.quoteName(tableName) + \" add column ...\"</code>  but for MySQL specifically it must be <code>\"alter table \"+dialect.quoteName(tableName) + \" modify column ...\"</code>.</p> <p>Defining database-specific functionality tends to be writing <code>if (database instanceof ExampleDatabase)</code> blocks around the non-standard calls. Using \"instanceof\" means the block will apply to any subclasses of the given database.  For example, if your database is PostgreSQL compatible and therefore your Database class extensions <code>PostgresDatabase</code> then all the  <code>if (database instanceof PostgresDatabase)</code> checks will be used for your database as well.</p>"},{"location":"extensions/guides/additional-database/sql-generator/#implementing","title":"Implementing","text":"<p>When adding support for a new Database, there will be existing <code>SqlGenerator</code> implementations for all <code>SqlStatement</code> types.  It is usually easiest to subclass the existing SqlGenerator to leverage the standard logic, but it's not necessary. </p> <p>The naming pattern tends to be \"StatementName\" + \"Generator\". For example, AddColumnStatement -&gt; AddColumnGenerator. Database-specific classes append the database name to the end, like <code>AddColumnGeneratorOracle</code> </p>"},{"location":"extensions/guides/additional-database/sql-generator/#empty-constructor","title":"Empty Constructor","text":"<p>Like all Liquibase extensions, your SqlGenerator must have an empty constructor.</p>"},{"location":"extensions/guides/additional-database/sql-generator/#supportssqlstatement-database","title":"supports(SqlStatement, Database)","text":"<p>The supports function returns whether this SqlGenerator should be used for the given SqlStatement and Database combination.</p> <p>If you define your SqlGenerator class using generics, Liquibase will know the SqlStatement type you can support and not bother calling <code>supports()</code> unless the SqlStatement class is correct. Therefore you only have to check that the Database object is correct. </p> <p>You can normally check this with instanceof, but you can call methods on the Database object to check versions or whatever else may decide whether this class generates the correct SQL or not. </p>"},{"location":"extensions/guides/additional-database/sql-generator/#getpriority","title":"getPriority()","text":"<p>You must override getPriority() so it will be picked over the base implementation you are extending. If you do not override this function they will both  return the same priority and which is chosen is random.</p> <p>To ensure a higher value is returned, use something like <code>return super.getPriority() + 5</code>.</p>"},{"location":"extensions/guides/additional-database/sql-generator/#validatesqlstatement-database-sqlgeneratorchange-and-warn","title":"validate(SqlStatement, Database, SqlGeneratorChange) and warn","text":"<p>The validate method is used to check that the configuration of the SqlStatement is correct. It's the job of this function to ensure any required settings are set and any invalid settings are not used. </p> <p>When extending a base SqlGenerator, you can call <code>super.validate(statement, database, sqlGeneratorChain)</code> as a starting point, and then perform extra checks  (or remove not-actually-invalid errors) before returning the ValidationErrors.</p> <p>This method is always called, and so you do not need to re-validate settings in other methods.</p> <p>If you have no additional validation to perform vs. the base logic there is no need to override this method.</p> <p>The <code>warn(SqlStatement, Database, SqlGeneratorChange)</code> is similar to <code>validate</code> but returns non-fatal warnings to the user. </p>"},{"location":"extensions/guides/additional-database/sql-generator/#generatesqlsqlstatement-database-sqlgeneratorchain","title":"generateSql(SqlStatement, Database, SqlGeneratorChain)","text":"<p>This is the method that generates the SQL for your particular database. It returns an array of liquibase.sql.Sql objects and so a single <code>SqlStatement</code> class can create multiple underlying SQL statements. For example, <code>AddPrimaryKeyGenerator</code> may return a SQL call to add the primary key and another to reorganize the table.</p> <p>Depending on how different your SQL is from the base class, you can either call <code>super.generateSql()</code> and modify the objects in the array before returning it, or  create a new <code>Sql[]</code> array from scratch. It tends to be best to modify the SQL generated by the parent class because that keeps you from having to duplicate all the argument handling logic that already exists in the parent.</p> <p>Also remember to always check your parent class's method signature for settings it defines. It may have methods like <code>nullComesBeforeType()</code> which it uses to determine the final SQL and you simply have to override that method to return a different value.</p> <p>liquibase.sql.UnparsedSql is the implementation of <code>Sql</code> you will almost always want to use in your <code>Sql[]</code> array.</p> <p>When generating your SQL you should try as hard as possible to rely purely on the settings in the SqlStatement function to determine the SQL to generate. If you have to query the database for more information or check any other external information you must ensure <code>generateStatementsIsVolatile()</code> returns true. That lets Liquibase know that each run of the SqlStatement may generate different results and therefore can't be used in <code>update-sql</code> type operations.</p>"},{"location":"extensions/guides/additional-database/sql-generator/#register-your-class","title":"Register your Class","text":"<p>Like all extensions, your SqlGenerator must be registered by adding your class name to <code>META-INF/services/liquibase.sqlgenerator.SqlGenerator</code></p>"},{"location":"extensions/guides/additional-database/sql-generator/#example-code","title":"Example Code","text":"<pre><code>package com.example.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddColumnGenerator;\nimport liquibase.statement.core.AddColumnStatement;\n\npublic class AddColumnGeneratorExample extends AddColumnGenerator {\n    @Override\n    public int getPriority() {\n        return super.getPriority() + 5;\n    }\n\n    @Override\n    public Sql[] generateSql(AddColumnStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n        Sql[] originalSql = super.generateSql(statement, database, sqlGeneratorChain);\n\n        return new Sql[] {\n                new UnparsedSql(originalSql[0].toSql().replace(\"ALTER COLUMN\", \"MODIFY COLUMN\"))\n        };\n    }\n}\n</code></pre>"},{"location":"extensions/references/priority/","title":"Priority","text":"<p>Liquibase uses \"priority\" to determine the correct implementation classes to use at runtime. While the specific methods used to return the priority can vary depending on the interface, they all follow a consistent pattern.</p> <p>\"Priority\" is an integer, where the highest value wins. We allow a range of priority values to allow more and more specific implementations.</p> <p>For example: - An implementation that provides generic database support for a feature may return priority \"1\" - An implementation for most Postgresql variants returns a priority of \"5\" - An implementation for Redshift specifically returns a priority of \"10\" - An implementation for how you specifically use Redshift returns a priority of \"15\" - An implementation for how you specifically use Redshift in production returns a priority of \"20\"</p> <p>Extensions allow the existence of other extensions by leaving gaps above and below their priority for other extensions to fit into. </p>"}]}